---
title: "[Rust编程之道笔记]所有权"
linkTitle: "[Rust编程之道笔记]"
weight: 4010
date: 2021-12-06
description: >
 Rust编程之道一书 第5章 所有权
---

Rust受现代c++的启发，引入智能指针来管理堆内存。在rust中，所有权是系统性的概念，是rust语言的基础设施。

## 5.1 通用概念

编程语言中的值主要分成两类：

- 值类型（Value）：数据直接存储在栈中的数据类型
- 引用类型（Reference）：将数据存在堆中，而栈中值存放指向对重数据的地址（指针）

为了更精确的对复杂类型进行描述，引入值语义和引用语义：

- 值语义（Value Semantic）：按位复制以后，和原始对象无关
- 引用语义（Reference Semantic）：也叫指针语义。一般是指将数据存储于对内存中，通过栈内存的指针来管理堆内存的数据，并且引用语义禁止按位复制。

按位复制就是指栈复制，也叫浅复制，只复制栈上的数据。深复制就是对栈上和堆上的数据一起复制。

对于实现Copy trait的类型，其 clone 方法必须是按位复制的。

rust通过 Copy 这个标记 trait 将类型按值语义和引用语义做了精准的分类，帮助编译期检测出潜在的内存安全问题。

引用语义不能实现copy，但是可以实现 Clone 的 clone 方法，以实现深度复制，在需要时可以显示调用。

## 5.2 所有权机制

在所有权体制下，Rust引入新的语义：

- 复制（copy）：对应值语义。对于可以安全在栈上进行按位复制的类型，就只需要按位复制
- 移动（move）：对应引用语义。对于在堆上存储的数据，无法安全地在栈上进行按位复制。如果堆上的数据不变，只需要在栈上移动指向堆内存的指针地址，不仅保证了内存安全，也拥有与栈复制同样的性能。

**一个值的所有权被转移给另外一个变量绑定的过程，就叫做所有权转移。**

rust中每个值都有一个所有者，更进一步说就是，rust中分配的每块内存都有其所有者，所有者负责该内存的释放和读写权限，并且每次每个值只能有唯一的所有者，这就是rust的所有权机制（ownership）

### 所有权的特点

所有者拥有以下三种权限：

- 控制资源（不仅仅是内存）的释放
- 出借所有权，包括不可变（共享）的和可变（独占）的
- 转移所有权

对于可以实现 Copy 的复制语义类型来说，所有权并未改变。对于复合类型来说，是复制还是移动，取决于其成员的类型。

- 结构体：即使结构体的成员都是复制语义类型，但是rust也不会默认为其实现 Copy。需要手工添加 `#[derive(Debug, Copy, Clone)]`
- 枚举：类似结构体
- 元组：本身实现了 Copy，如果元素均为复制语义类型，则默认是按位复制，否则会执行移动语义。
- 数组：类似元组
- Option类型：类似元组

## 5.3 绑定、作用域和生命周期

Rust 使用 let 关键字来生命变量。let 有 let banding 之意，let 声明的变量实际不是传统意义上的变量，而是指一种绑定语义。let 绑定了标识符和内存，而且使得标识符对那块内存拥有了所有权，因此被称为“绑定”。

### 5.3.1 不可变与可变

不可变（Immutable）的优点：

- 多线程并发时，不可变的数据可以安全地在线程间共享
- 函数的“副作用”可以得到控制

Rust生命的绑定默认不可变，如果需要修改，Rust 提供关键字 mut 来声明可变绑定。

### 5.3.2 绑定的时间属性-声明周期

变量绑定具有“时空”双重属性：

- 空间属性：指标识符与内存空间进行了绑定
- 时间属性：指绑定的时效性，也就是它的生存周期

除了 let 声明外，还有一些场景会常见新的词法作用域：

- 花括号`{}`

- match 匹配

- 循环语句

- if let 和 while let 块

- 函数

    函数参数是复制语义时按位复制，是移动语义时会转移所有权

- 闭包

    闭包会创建新的作用域，对于环境变量来说有一下三种捕获方式：

    1. 对于复制语义类型，以不可变应用（`&T`）来捕获
    2. 对于移动语义类型，执行移动语义转移所有权来捕获
    3. 对于可变绑定，如果在闭包中包含对其进行修改的操作，则以可变引用(`&mut`)来捕获

## 5.4 所有权借用

### 引用与借用

引用（Reference）是Rust提供的一种指针语义。应用是基于指针的实现，和指针的区别是：

- 指针保存的是指向内存的地址
- 引用可以看做某块内存的别名（alias），使用引用需要满足编译期的各种安全检查规则。

引用分为不可变引用（使用`&`操作符）和可变引用(使用`&mut`操作符)。

在所有权系统中，引用`&x`可称为 x 的借用（Borrowing），通过 `&` 操作符来完成所有权的租借。借用所有权不会引起变量所有权的转移。

借用所有权会让所有者（owner）收到如下限制：

- 在不可变借用期间，所有者不能修改资源，并且也不能再进行可变借用
- 在可变借用期间，所有者不能访问资源，并且也不能再出借所有权

**引用在离开作用域之时，就是归还所有权之时。**

### 借用规则

为了保证内存安全，借用必须遵循以下三个规则：

- 规则一：借用的生命周期不能长于出借方（拥有所有权的对象）的生命周期

- 规则二：可变借用（引用）不能有别名（Alias，即其他不可变引用）,因为可变借用具有独占性
- 规则三：不可变借用（引用）不能再次出借为可变借用

规则一是为了防止出现悬垂指针，规则二和规则三总结为一条核心原则：**共享不可变，可变不共享**。规则二和规则三描述的不可变借用和可变借用就相当于内存的读写锁，同一时刻，只能拥有一个写锁，或者多个读锁，不能同时拥有。



