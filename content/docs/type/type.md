---
title: "Rust类型系统概述"
linkTitle: "类型系统概述"
weight: 2001
date: 2021-04-02
description: >
  Rust类型系统概述
---

### 类型系统介绍

类型系统的分类：

- 静态类型：在编译期进行类型检查的语言
- 动态类型：在运行期进行类型检查的语言

编程语言：

- 强类型：不容许类型的自动隐式转换，在强制转换前不同类型无法进行计划
- 弱类型：容许类型的自动隐式转换

### Rust的类型系统

Rust 是强类型而且类型安全的静态语言。

- Rust中一切皆表达式
- 表达式都有值
- 值都有类型

所以：Rust中一切皆类型！

### 多态性

**多态类型系统**的定义：容许一段代码在不同的上下文中具有不同类型的类型系统

按照多态发生的时机来划分：

- 静多态（Static Polymorphism） ：发生在编译期，静多态牺牲灵活性获取性能
- 动多态（Dynaimc Polymorphism）：发生在运行时，动多态牺牲性能获取灵活性。

动多态在运行时需要查表，占用较多空间，所以一般情况下都使用静多态。

**Rust 语言同时支持静多态和动多态**，其中静多态是一种零成本抽象。

现代编程语言包含三种多态形式：

- 参数化多态（Parametric polymorphism）
	
	一般是静多态，实际就是指泛型。泛型使得语言极具表达力，同时也保证了静态类型安全。

- AD-hoc 多态（ad-hoc polymorphism）

	一般是静多态，也叫特定多态。
	
	Ad-hoc 多态是指同一种行为定义，在不同的上下文中会有不同的行为实现。
	
	Rust 受 Haskell 启发，使用 trait 来支持 Ad-hoc 多态。

- 子类型多态（subtype polymorphism）

	一般是动多态，常用于面向对象的语言中，如Java。子类型多态代表一种包含关系：父类型的值包含了子类型的值，所以子类型的值可以看成父类型的值。
	
	Rust 中没有类型Java的继承概念，因此不存在子类型多态。
	

总结：Rust 的类型系统目前只支持参数化多态和Ad-hoc多态，即泛型和trait。

### 类型大小

Rust 代码被编译为 LLVM IR，其中携带了内存分配的信息。

因此，Rust编译器需要实现知道类型的大小，才能分配合理的内存。

Rust 中绝大部分类型都是在编译期内可确定大小的类型（称为Sized Type)，也有少量的动态大小的类型（Dynamic Sized Type，简写为 DST）。

对于DST，Rust提供了引用类型，如字符串切片 &str ，由指针和长度信息组成。

除了可确定大小类型和 DST 类型，Rust 还支持零大小类型（Zero Sized Type， ZST）。

### 类型推导

Rust 只能在局部范围内进行类型推导。

当编译器无法从上下文中自动推导出类型时，就需要明确的标注类型信息，方式有：

```rust
let x = "1";
// 报错：type annotations required
//println!("{:?}", x.parse().unwrap());
// 需要明确注明类型
let int_x:i32 = x.parse().unwrap();

// 或者采用 turbofish 操作符为泛型函数标注类型
println!("{:?}", x.parse::<i32>().unwrap());
```




