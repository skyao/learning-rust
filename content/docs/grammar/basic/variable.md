---
title: "Rust的变量"
linkTitle: "变量"
date: 2021-03-29
weight: 1120
description: >
  Rust的变量
---

## 不可变变量

变量默认是不可改变的（immutable），这是Rust 提供的安全性和简单并发性来编写代码的众多方式之一。

let 关键字用于定义变量，默认定义的是不可变变量：

```rust
fn main() {
    // 可以通过类型推导得到变量类型，因此可以不制定变量类型
    let a = 1;
    // 也可以明确指定变量类型
    let b: bool = true;
}
```

Rust 编译器保证，如果声明一个值不会变，它就真的不会变。这意味着当阅读和编写代码时，不需要追踪一个值如何和在哪可能会被改变，从而使得代码易于推导。

## 可变变量

变量只是默认不可变；正如在第二章所做的那样，你可以在变量名之前加 mut 来使其可变。除了允许改变值之外，mut 向读者表明了其他代码将会改变这个变量值的意图。

```rust
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

## 权衡使用

- 使用大型数据结构时，适当地使用可变变量，可能比复制和返回新分配的实例更快
- 对于较小的数据结构，总是创建新实例，采用更偏向函数式的编程风格，可能会使代码更易理解，为可读性而牺牲性能或许是值得的

当多种类型均有可能时，必须增加类型注解：

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

## 变量隐藏

可以定义一个与之前变量同名的新变量，而新变量会 **隐藏(Shadowing)** 之前的变量。

Rustacean 们称之为第一个变量被第二个 **隐藏** 了，这意味着使用这个变量时会看到第二个值。可以用相同变量名称来隐藏一个变量，以及重复使用 `let` 关键字来多次隐藏，如下所示：

```rust
fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!("The value of x is: {}", x);
}
```

当再次使用 `let` 时，实际上创建了一个新变量，我们可以改变值的类型，但复用这个名字:

```rust
let spaces = "   ";
let spaces = spaces.len();
```



