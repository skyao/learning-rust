---
date: 2019-03-05T07:00:00+08:00
title: 整型
menu:
  main:
    parent: "grammar-type"
weight: 321
description : "Rust中的整型"
---



### Rust 中的整型

Rust 内建的整数类型。在有符号列和无符号列中的每一个变体（例如，`i16`）都可以用来声明整数值的类型。

| 长度   | 有符号  | 无符号  |
| ------ | ------- | ------- |
| 8-bit  | `i8`    | `u8`    |
| 16-bit | `i16`   | `u16`   |
| 32-bit | `i32`   | `u32`   |
| 64-bit | `i64`   | `u64`   |
| arch   | `isize` | `usize` |

注意：`isize` 和 `usize` 类型依赖运行程序的计算机架构：64 位架构上它们是 64 位的， 32 位架构上它们是 32 位的。

### 整型字面值

可以使用表格中的任何一种形式编写数字字面值。注意除 byte 以外的所有数字字面值允许使用类型后缀，例如 `57u8`，同时也允许使用 `_` 做为分隔符以方便读数，例如`1_000`。

| 数字字面值       | 例子          | 说明       |
| ---------------- | ------------- | ---------- |
| Decimal          | `98_222`      |            |
| Hex              | `0xff`        | 16进制     |
| Octal            | `0o77`        | 8进制      |
| Binary           | `0b1111_0000` | 2进制      |
| Byte (`u8` only) | `b'A'`        | 字节字面量 |

那么该使用哪种类型的数字呢？如果拿不定主意，Rust 的默认类型通常就很好，数字类型默认是 `i32`：它通常是最快的，甚至在 64 位系统上也是。`isize` 或 `usize` 主要作为某些集合的索引。

### 整型溢出

 “整型溢出”（“integer overflow” ）在 Rust 中有一些有趣的规则：

- 当在 debug 模式编译时，Rust 检查这类问题并使程序 *panic*
- 在 release 构建中，Rust 不检测溢出，相反会进行一种被称为 “two’s complement wrapping” 的操作。

	简而言之，`256` 变成 `0`，`257` 变成 `1`，依此类推。
	
	依赖溢出被认为是一种错误，即便可能出现这种行为。如果你确实需要这种行为，标准库中有一个类型显式提供此功能，`Wrapping`。



